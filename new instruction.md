Project Brief: Language Crash Test Application PackageObjective:Refactor the existing collection of scripts into a robust, installable Python application package named language_crash_test. The application's purpose is to stress-test the Microsoft Copilot for Windows UI by automating a long, bilingual conversation.The final application must provide both a command-line interface (CLI) and a graphical user interface (GUI) for configuration and execution. A critical requirement is that the GUI must remain fully responsive and never freeze, even during intensive testing.1. Core Architecture: A Modular PackageThe project must be structured as a Python package. The file structure should be as follows:language_crash_test/
│
├── language_crash_test/
│   ├── __init__.py
│   ├── automation.py       # Core pywinauto logic
│   ├── config.py           # Configuration class
│   ├── debug.py            # UI element inspection script
│   ├── generator.py        # Bilingual message generation
│   ├── gui.py              # PySide6 GUI main window
│   └── worker.py           # PySide6 QObject worker for threading
│
├── tests/
│   ├── test_config.py
│   └── test_generator.py
│
├── main.py                 # Main application entry point
├── requirements.txt
└── README.md
Module Responsibilities:main.py: The sole entry point for the application. It will use argparse to handle command-line arguments (--gui, --cli, --debug) and launch the appropriate functionality.config.py: Contains a Config dataclass to manage all application settings. It must support serialization to and from a config.json file.generator.py: A module to procedurally generate a list of bilingual (English and Norwegian) test messages, including special characters (æ, ø, å) and emojis.automation.py: Contains the core UI automation logic using pywinauto. This module should be completely decoupled from the GUI and should contain a primary function like run_stress_test_logic(config, logger).debug.py: The helper script that uses pywinauto to inspect and print the UI control tree of the target application.gui.py: Defines the main application window using PySide6. It will handle user input for configuration but will delegate the actual test execution to the worker thread.worker.py: Defines the StressTestWorker class which inherits from QObject. This worker will run the automation logic from automation.py in a separate thread to prevent the GUI from freezing.2. GUI Implementation (PySide6) and Freeze PreventionThis is the most critical part of the refactoring. The GUI must be built for stability and responsiveness.Key GUI Requirements:Framework: The GUI must be built exclusively with PySide6.Non-Blocking Operation: All long-running tasks, specifically the pywinauto stress test, must be executed in a separate worker thread.Worker Threading Model:Use the QThread and QObject worker pattern.The gui.py module will create an instance of worker.StressTestWorker.This worker instance must be moved to a new QThread instance using worker.moveToThread(thread).Thread-Safe Communication:Communication from the worker thread back to the GUI thread must be handled exclusively through Qt Signals and Slots.The worker should have signals like progress = Signal(str), finished = Signal(), and error = Signal(str).The GUI will connect its update methods (slots) to these signals.Directly calling GUI update methods from the worker thread is strictly forbidden.Thread-Safe Imports: To prevent cross-thread conflicts with UI automation libraries, pywinauto and the automation.py module must be imported inside the worker's main run() method, not at the top level of the worker.py file.Signal Throttling: To prevent the GUI from freezing due to a high frequency of progress updates, implement a signal throttling/buffering mechanism. Log messages from the worker should be collected over a short period (e.g., 200ms) and sent to the GUI as a single, consolidated signal.Memory Management: Ensure all PySide6 widgets are created with a parent to prevent memory leaks.Timeout Protection: Implement a QTimer-based timeout mechanism in the GUI to automatically terminate the worker thread if the test runs for an unexpectedly long time, preventing indefinite hangs.3. UI Automation and ConfigurationAutomation Logic (automation.py):Continue to use pywinauto as the sole UI automation library.The logic should focus on dynamic element discovery. Instead of hardcoded IDs, use a combination of known patterns and the debug.py script as a fallback to intelligently find the text input, send button, and new conversation controls.The main function should be self-contained and accept config and logger objects, making it callable from both the CLI and the GUI worker.Configuration (config.py):Centralize all user-configurable parameters into the Config dataclass.This includes message count, wait times, logging settings, and UI element detection patterns.The application should create a default config.json on first run if one does not exist.4. Final Application FlowUser runs python main.py --gui.The Configurator window from gui.py appears.User adjusts settings and clicks "Start Test".The GUI instantiates StressTestWorker, moves it to a QThread, and starts the thread.The worker's run() method begins execution in the new thread.Inside the worker thread, it imports automation.py.It calls automation.run_stress_test_logic(), redirecting its stdout to the throttled signal emitter.The automation logic interacts with the Copilot UI, and its log output is buffered.Periodically, the buffer is flushed, and a progress signal containing a batch of log messages is emitted.The GUI's main thread receives the signal and updates the output text area in a single, efficient operation.Upon completion or error, the worker emits the finished or error signal, and the GUI thread performs cleanup and displays a final status message.